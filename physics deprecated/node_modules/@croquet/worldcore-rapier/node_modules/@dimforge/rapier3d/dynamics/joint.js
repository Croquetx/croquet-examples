var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { VectorOps, RotationOps } from "../math";
import { RawJointParams } from "../raw";
/**
 * An enum grouping all possible types of joints:
 * - `Ball`: A Ball joint that removes all relative linear degrees of freedom between the affected bodies.
 * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.
 * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected
 *                bodies except for the translation along one axis.
 * - `Revolute`: (3D only) A revolute joint that removes all degrees of freedom between the affected
 *               bodies except for the rotation along one axis.
 */
export var JointType;
(function (JointType) {
    JointType[JointType["Ball"] = 0] = "Ball";
    JointType[JointType["Fixed"] = 1] = "Fixed";
    JointType[JointType["Prismatic"] = 2] = "Prismatic";
    // #if DIM3
    JointType[JointType["Revolute"] = 3] = "Revolute";
    // #endif
})(JointType || (JointType = {}));
export var SpringModel;
(function (SpringModel) {
    SpringModel[SpringModel["Disabled"] = 0] = "Disabled";
    SpringModel[SpringModel["VelocityBased"] = 1] = "VelocityBased";
    SpringModel[SpringModel["AccelerationBased"] = 2] = "AccelerationBased";
    SpringModel[SpringModel["ForceBased"] = 3] = "ForceBased";
})(SpringModel || (SpringModel = {}));
var Joint = /** @class */ (function () {
    function Joint(rawSet, handle) {
        this.rawSet = rawSet;
        this.handle = handle;
    }
    /**
     * Checks if this joint is still valid (i.e. that it has
     * not been deleted from the joint set yet).
     */
    Joint.prototype.isValid = function () {
        return this.rawSet.contains(this.handle);
    };
    /**
     * The unique integer identifier of the first rigid-body this joint it attached to.
     */
    Joint.prototype.bodyHandle1 = function () {
        return this.rawSet.jointBodyHandle1(this.handle);
    };
    /**
     * The unique integer identifier of the second rigid-body this joint is attached to.
     */
    Joint.prototype.bodyHandle2 = function () {
        return this.rawSet.jointBodyHandle2(this.handle);
    };
    /**
     * The type of this joint given as a string.
     */
    Joint.prototype.type = function () {
        return this.rawSet.jointType(this.handle);
    };
    // #if DIM3
    /**
     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.
     */
    Joint.prototype.frameX1 = function () {
        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));
    };
    // #endif
    // #if DIM3
    /**
     * The rotation matrix that aligns this joint's second local axis to the `x` axis.
     */
    Joint.prototype.frameX2 = function () {
        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));
    };
    // #endif
    /**
     * The position of the first anchor of this joint.
     *
     * The first anchor gives the position of the points application point on the
     * local frame of the first rigid-body it is attached to.
     */
    Joint.prototype.anchor1 = function () {
        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));
    };
    /**
     * The position of the second anchor of this joint.
     *
     * The second anchor gives the position of the points application point on the
     * local frame of the second rigid-body it is attached to.
     */
    Joint.prototype.anchor2 = function () {
        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));
    };
    /**
     * The first axis of this joint, if any.
     *
     * For joints where an application axis makes sense (e.g. the revolute and prismatic joins),
     * this returns the application axis on the first rigid-body this joint is attached to, expressed
     * in the local-space of this first rigid-body.
     */
    Joint.prototype.axis1 = function () {
        return VectorOps.fromRaw(this.rawSet.jointAxis1(this.handle));
    };
    /**
     * The second axis of this joint, if any.
     *
     * For joints where an application axis makes sense (e.g. the revolute and prismatic joins),
     * this returns the application axis on the second rigid-body this joint is attached to, expressed
     * in the local-space of this second rigid-body.
     */
    Joint.prototype.axis2 = function () {
        return VectorOps.fromRaw(this.rawSet.jointAxis2(this.handle));
    };
    return Joint;
}());
export { Joint };
var UnitJoint = /** @class */ (function (_super) {
    __extends(UnitJoint, _super);
    function UnitJoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Are the limits enabled for this joint?
     */
    UnitJoint.prototype.limitsEnabled = function () {
        return this.rawSet.jointLimitsEnabled(this.handle);
    };
    /**
     * The min limit of this joint.
     */
    UnitJoint.prototype.limitsMin = function () {
        return this.rawSet.jointLimitsMin(this.handle);
    };
    /**
     * The max limit of this joint.
     */
    UnitJoint.prototype.limitsMax = function () {
        return this.rawSet.jointLimitsMax(this.handle);
    };
    UnitJoint.prototype.configureMotorModel = function (model) {
        this.rawSet.jointConfigureMotorModel(this.handle, model);
    };
    UnitJoint.prototype.configureMotorVelocity = function (targetVel, factor) {
        this.rawSet.jointConfigureUnitMotorVelocity(this.handle, targetVel, factor);
    };
    UnitJoint.prototype.configureMotorPosition = function (targetPos, stiffness, damping) {
        this.rawSet.jointConfigureUnitMotorPosition(this.handle, targetPos, stiffness, damping);
    };
    UnitJoint.prototype.configureMotor = function (targetPos, targetVel, stiffness, damping) {
        this.rawSet.jointConfigureUnitMotor(this.handle, targetPos, targetVel, stiffness, damping);
    };
    return UnitJoint;
}(Joint));
export { UnitJoint };
var FixedJoint = /** @class */ (function (_super) {
    __extends(FixedJoint, _super);
    function FixedJoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FixedJoint;
}(Joint));
export { FixedJoint };
var PrismaticJoint = /** @class */ (function (_super) {
    __extends(PrismaticJoint, _super);
    function PrismaticJoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PrismaticJoint;
}(UnitJoint));
export { PrismaticJoint };
// #if DIM3
var BallJoint = /** @class */ (function (_super) {
    __extends(BallJoint, _super);
    function BallJoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BallJoint.prototype.configureMotorModel = function (model) {
        this.rawSet.jointConfigureMotorModel(this.handle, model);
    };
    BallJoint.prototype.configureMotorVelocity = function (targetVel, factor) {
        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);
    };
    BallJoint.prototype.configureMotorPosition = function (targetPos, stiffness, damping) {
        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);
    };
    BallJoint.prototype.configureMotor = function (targetPos, targetVel, stiffness, damping) {
        this.rawSet.jointConfigureBallMotor(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, targetVel.x, targetVel.y, targetVel.z, stiffness, damping);
    };
    return BallJoint;
}(Joint));
export { BallJoint };
var RevoluteJoint = /** @class */ (function (_super) {
    __extends(RevoluteJoint, _super);
    function RevoluteJoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RevoluteJoint;
}(UnitJoint));
export { RevoluteJoint };
// #endif
var JointParams = /** @class */ (function () {
    function JointParams() {
    }
    /**
     * Create a new joint descriptor that builds Ball joints.
     *
     * A ball joints allows three relative rotational degrees of freedom
     * by preventing any relative translation between the anchors of the
     * two attached rigid-bodies.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     */
    JointParams.ball = function (anchor1, anchor2) {
        var res = new JointParams();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.jointType = JointType.Ball;
        return res;
    };
    /**
     * Creates a new joint descriptor that builds a Fixed joint.
     *
     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their
     * anchor and local frames coincide in world-space.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.
     */
    JointParams.fixed = function (anchor1, frame1, anchor2, frame2) {
        var res = new JointParams();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.frame1 = frame1;
        res.frame2 = frame2;
        res.jointType = JointType.Fixed;
        return res;
    };
    // #if DIM3
    /**
     * Creates a new joint descriptor that builds a Prismatic joint.
     *
     * A prismatic joint removes all the degrees of freedom between the
     * affected bodies, except for the translation along one axis.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param axis1 - Axis of the joint, expressed in the local-space of the first rigid-body it is attached to.
     * @param tangent1 - A vector orthogonal to `axis1`. It is used to compute a basis orthonormal
     *                   to the joint's axis. If this tangent is set to the zero vector, the orthonormal
     *                   basis will be automatically computed arbitrarily.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param axis2 - Axis of the joint, expressed in the local-space of the second rigid-body it is attached to.
     * @param tangent2 - A vector orthogonal to `axis2`. It is used to compute a basis orthonormal
     *                   to the joint's axis. If this tangent is set to the zero vector, the orthonormal
     *                   basis will be automatically computed arbitrarily.
     */
    JointParams.prismatic = function (anchor1, axis1, tangent1, anchor2, axis2, tangent2) {
        var res = new JointParams();
        res.anchor1 = anchor1;
        res.axis1 = axis1;
        res.tangent1 = tangent1;
        res.anchor2 = anchor2;
        res.axis2 = axis2;
        res.tangent2 = tangent2;
        res.jointType = JointType.Prismatic;
        return res;
    };
    /**
     * Create a new joint descriptor that builds Revolute joints.
     *
     * A revolute joint removes all degrees of freedom between the affected
     * bodies except for the rotation along one axis.
     *
     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param axis1 - Axis of the joint, expressed in the local-space of the first rigid-body it is attached to.
     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
     *                  local-space of the rigid-body.
     * @param axis2 - Axis of the joint, expressed in the local-space of the second rigid-body it is attached to.
     */
    JointParams.revolute = function (anchor1, axis1, anchor2, axis2) {
        var res = new JointParams();
        res.anchor1 = anchor1;
        res.anchor2 = anchor2;
        res.axis1 = axis1;
        res.axis2 = axis2;
        res.jointType = JointType.Revolute;
        return res;
    };
    // #endif
    JointParams.prototype.intoRaw = function () {
        var rawA1 = VectorOps.intoRaw(this.anchor1);
        var rawA2 = VectorOps.intoRaw(this.anchor2);
        var rawAx1;
        var rawAx2;
        var result;
        var limitsEnabled = false;
        var limitsMin = 0.0;
        var limitsMax = 0.0;
        switch (this.jointType) {
            case JointType.Ball:
                result = RawJointParams.ball(rawA1, rawA2);
                break;
            case JointType.Fixed:
                var rawFra1 = RotationOps.intoRaw(this.frame1);
                var rawFra2 = RotationOps.intoRaw(this.frame2);
                result = RawJointParams.fixed(rawA1, rawFra1, rawA2, rawFra2);
                rawFra1.free();
                rawFra2.free();
                break;
            case JointType.Prismatic:
                rawAx1 = VectorOps.intoRaw(this.axis1);
                rawAx2 = VectorOps.intoRaw(this.axis2);
                if (!!this.limitsEnabled) {
                    limitsEnabled = true;
                    limitsMin = this.limits[0];
                    limitsMax = this.limits[1];
                }
                // #if DIM3
                var rawTa1 = VectorOps.intoRaw(this.tangent1);
                var rawTa2 = VectorOps.intoRaw(this.tangent2);
                result = RawJointParams.prismatic(rawA1, rawAx1, rawTa1, rawA2, rawAx2, rawTa2, limitsEnabled, limitsMin, limitsMax);
                rawTa1.free();
                rawTa2.free();
                // #endif
                rawAx1.free();
                rawAx2.free();
                break;
            // #if DIM3
            case JointType.Revolute:
                rawAx1 = VectorOps.intoRaw(this.axis1);
                rawAx2 = VectorOps.intoRaw(this.axis2);
                result = RawJointParams.revolute(rawA1, rawAx1, rawA2, rawAx2);
                rawAx1.free();
                rawAx2.free();
                break;
            // #endif
        }
        rawA1.free();
        rawA2.free();
        return result;
    };
    return JointParams;
}());
export { JointParams };
//# sourceMappingURL=joint.js.map